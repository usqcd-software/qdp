\input texinfo   @c -*-texinfo-*-
@setfilename qdpc.info
@settitle QDP/C User Manual

@include qdpdefs.texi

@c start titlepage, only used in TeX mode
@titlepage
@title QDP/C User Manual
Version 1.5.1

This document provides a detailed description of the C implementation of the@*
SciDAC Level 2 QDP Data Parallel interface.

@author C. DeTar and J.C. Osborn
with the SciDAC Software Committee
@end titlepage

@c top node for non-TeX output
@ifnottex
@node Top
@top QDP/C User Manual
Version 1.5.1

This document provides a detailed description of the C implementation of the@*
SciDAC Level 2 QDP Data Parallel interface.
@end ifnottex

@contents

@menu
* Introduction::          Introduction to QDP/C.
* Compilation with QDP::  How to compile a program that uses QDP.
* Datatypes::             Datatypes.
* QDP Functions::         QDP Functions.
* Function Details::      Function Details.
@end menu


@c ====================================================================
@node     Introduction
@chapter  Introduction
@c ====================================================================

This is the detailed user's guide for the C binding of the QDP Data Parallel
Applications Programmer Interface developed under the auspices of the
U.S. Department of Energy Scientific Discovery through Advanced
Computing (SciDAC) program.

The QDP Level 2 API has the following features:

@itemize @bullet
@item
Provides data parallel operations (logically SIMD) on all sites
across the lattice or on subsets of these sites.
@item
Operates on lattice objects, which have an implementation-dependent
data layout that is not visible above this API.
@item
Hides details of how the implementation maps onto a given
architecture, namely how the logical problem grid (i.e. lattice) is
mapped onto the machine architecture.
@item
Allows asynchronous (non-blocking) shifts of lattice level
objects over any permutation map of sites onto sites. However, from
the user's view these instructions appear blocking and in fact may be
so in some implementation.
@item
Provides some combined shift and linear algebra instructions for
convenience and optimization.
@item
Provides fill operations (filling a lattice quantity from a
scalar value(s)), global reduction operations, and lattice-wide
operations on various data-type primitives, such as matrices, vectors,
and tensor products of matrices (propagators).
@end itemize


@c ====================================================================
@node     Compilation with QDP
@chapter  Compilation with QDP
@c ====================================================================

@section Generic header and macros

As described above, normally the user selects a prevailing color and
precision for the entire calculation.  In that case it is permissible
to use the generic function names and datatypes, making it possible to
change colors and precision with a simple recompilation, if desired.
For this purpose the generic header file is @code{qdp.h}.  The
following macros must be defined by the user prior to including this
header file:

@multitable @columnfractions .2 .23
@hline
@item Required Macro     @tab Choices
@hline
@item @qdpPrecisionMacro @tab 'D', 'F'
@item @qdpNcMacro        @tab number of colors
@hline
@end multitable

@noindent
Single quotes are required around nonnumeric values.  
In the C implementation of QDP the number of spins is set to 4 when
the library is built.

An additional macro is available to the user, but is
normally set to its default value according to the
macro @qdpNcMacro{}.

@multitable @columnfractions .2 .15
@hline
@item Optional Macro  @tab Choices
@hline
@item @qdpColorsMacro @tab 2, 3, 'N'
@hline
@end multitable

@noindent
This is the macro that determines the color namespace for the generic
functions.  Its default value is @emph{2} when @qdpNcMacro{} is @emph{2},
@emph{3} when @emph{3}, and @emph{N} otherwise.
If for some reason a users wishes to work with the @emph{N} namespace
for two or three colors, rather than the more efficient @emph{2} or @emph{3}
namespace, he/she may do so by setting this macro to @emph{'N'} explicitly.

A sample preamble for double precision SU(3) reads

@example
#define QDP_Precision 'D'
#define QDP_Nc 3
#include <qdp.h>
@end example

@noindent
with the include search path set to @file{QDP_HOME/include}
and @file{QDP_HOME} set to the home directory for QDP.
With such a preamble the generic function names and datatypes are
automatically mapped to the appropriate specific types.
Of course the precision and color macros can also be defined
through a compiler flag, as in

@command{gcc -DQDP_Precision=\'D\' -DQDP_Nc=3 ...}

@noindent
The single quotes are required and they must each be preceded by a
backslash to keep them from being eaten by the shell.

For SU(4) one might do

@example
#define QDP_Precision 'F'
#define QDP_Nc 4
#include <qdp.h>
@end example

@noindent
The maximum number of colors is determined by the QLA library.

@section Libraries

Normally, it is necessary to link five QDP libraries for a given
choice of color and precision.  Other libraries may be required by the
implementation.  Routines involving only integers and the random state
are common to all choices.  Routines involving only real or complex
numbers are common to all colors.  Thus for single precision SU(3)
the required libraries are linked through

@command{-lqdp_common -lqdp_int -lqdp_f -lqdp_f3 -lm}

@noindent
with the library search path set to @file{QDP_HOME/lib}.
A complete list of the QDP libraries is given below.
Each library will depend on the corresponding QLA library.
Also since global sums are done in a higher precision, using them
requires linking to QLA libraries of the next higher precision in
addition to the corresponding conversion library.

@multitable @columnfractions .25 .45
@hline
@item Name                      @tab Purpose
@hline
@item @file{libqdp_common.a}    @tab QDP utilities
@item @file{libqdp_int.a}       @tab integer and boolean
@item @file{libqdp_f.a}         @tab real and complex single precision
@item @file{libqdp_d.a}         @tab real and complex double precision
@item @file{libqdp_df.a}        @tab real and complex precision conversion
@item @file{libqdp_f2.a}        @tab 2 color single precision
@item @file{libqdp_d2.a}        @tab 2 color double precision
@item @file{libqdp_df2.a}       @tab 2 color precision conversion
@item @file{libqdp_f3.a}        @tab 3 color single precision
@item @file{libqdp_d3.a}        @tab 3 color double precision
@item @file{libqdp_df3.a}       @tab 3 color precision conversion
@item @file{libqdp_fn.a}        @tab N color single precision
@item @file{libqdp_dn.a}        @tab N color double precision
@item @file{libqdp_dfn.a}       @tab N color precision conversion
@hline
@end multitable

@section Nonuniform color and precision

Users wishing to vary color and precision within a single calculation
must use specific type names and function names whenever these types
and names differ from the prevailing precision and color.
For example, if an SU(3) calculation is done primarly in single
precision, but has double precision components, the following preamble
is appropriate:

@example
#define QDP_Precision 'F'
#define QDP_Nc 3
#include <qdp.h>
#include <qdp_d.h>
#include <qdp_df.h>
#include <qdp_d3.h>
#include <qdp_df3.h>
@end example

@noindent
and the following linkage to get the corresponding libraries:

@noindent
@command{-lqdp_common -lqdp_int -lqdp_f -lqdp_f3 -lqdp_d -lqdp_d3 -lqdp_df -lqdp_df3 -lm}

As in the previous example, the single precision components for
SU(3) are automatically included through @file{qdp.h}.  Then we need
the corresponding double precision components.  And we also need the
@code{DF} libraries to do conversions between single and double
precision.  They, too have colored and noncolored members.

The following table lists all the QDP headers.

@multitable @columnfractions .3 .7
@hline
@item Name              @tab Purpose
@hline
@item @file{qdp.h}      @tab Master header and QDP utilities
@item @file{qdp_int.h}  @tab integers, boolean
@item @file{qdp_f.h}    @tab real, complex, single precision
@item @file{qdp_d.h}    @tab real, complex, double precision
@item @file{qdp_df.h}   @tab real, complex, precision conversion
@item @file{qdp_f2.h}   @tab SU(2), single precision
@item @file{qdp_d2.h}   @tab SU(2), double precision
@item @file{qdp_df2.h}  @tab SU(2), precision conversion
@item @file{qdp_f3.h}   @tab SU(3), single precision
@item @file{qdp_d3.h}   @tab SU(3), double precision
@item @file{qdp_df3.h}  @tab SU(3), precision conversion
@item @file{qdp_fn.h}   @tab SU(N), single precision
@item @file{qdp_dn.h}   @tab SU(N), double precision
@item @file{qdp_dfn.h}  @tab SU(N), precision conversion
@hline
@end multitable


@c ====================================================================
@node     Datatypes
@chapter  Datatypes
@c ====================================================================

The @math{N_d} dimensional lattice consists of all the space-time sites in
the problem space.  Lattice data are fields on these sites.  A data
primitive describes data on a single site.  The lattice fields consist
of the primitives over all sites.  We do not define data types
restricted to a subset of the lattice -- rather, lattice fields occupy
the entire lattice.

@section Generic Names

The linear algebra portion of the QDP API is designed to resemble the
Level 1 QLA API.  Thus the datatypes and function naming conventions
are similar.  As with QLA there are two levels of generic naming:
fully generic in which both color and precision may be controlled
globally through two macros and color-generic in which precision is
explicit but not color.  Generic naming applies to datatypes, module
names, and accessor macros and follows similar rules.

Names for fully generic datatypes are listed in the table below.

@multitable @columnfractions .3 .2 .5
@hline
@item Name @tab Abbreviation @tab Description
@hline
@item @ctS @tab @aS          @tab implementation dependent
@item @ctI @tab @aI          @tab integer
@item @ctR @tab @aR          @tab real
@item @ctC @tab @aC          @tab complex
@item @ctV @tab @aV          @tab one-spin, @math{N_c} color spinor
@item @ctH @tab @aH          @tab two-spin, @math{N_c} color spinor
@item @ctD @tab @aD          @tab four-spin, @math{N_c} color spinor
@item @ctM @tab @aM          @tab @math{N_c \times N_c} complex matrix
@item @ctP @tab @aP          @tab @math{4 N_c \times 4 N_c} complex matrix
@hline
@end multitable

@noindent
The name for the corresponding primitive type, also known as the QLA
type, is obtained by replacing the @code{QDP} prefix with a @code{QLA}
prefix.  Thus @ctqlaM{} is the primitive (QLA) type associated
with the field @ctM{}.

Names for color-generic datatypes are obtained by inserting
@code{_F} for single precision or @code{_D} for double precision
after @code{QDP} where appropriate.
Thus @code{QDP_D_ColorMatrix} specifies a double precision color
matrix with color to be set through a global macro.

A long double precision type with abbreviation @code{Q} is defined for
QLA, but currently not for QDP.

@section Specific Types for Color and Precision

According to the chosen color and precision, names for specific
floating point types are constructed from names for generic types.
Thus @tM becomes @code{QDP_PC_ColorMatrix}, where the precision
@code{P} is @code{F} or @code{D} according to the table below

@float
@multitable @columnfractions .3 .7
@hline
@item Abbreviation @tab Description
@hline
@item @code{F}     @tab single precision
@item @code{D}     @tab double precision
@hline
@end multitable
@end float

@noindent
and @code{C} is @code{2}, @code{3}, or @code{N}, if color is a
consideration, as listed below.

@multitable @columnfractions .3 .7
@hline
@item Abbreviation @tab Description
@hline
@item @code{2}     @tab SU(2)
@item @code{3}     @tab SU(3)
@item @code{N}     @tab SU(N)
@hline
@end multitable

@noindent
If the datatype carries no color, the color label is omitted.
Integers also have no precision label.  Likewise for functions, if
none of the arguments carry color, the color label is omitted, and if
all numeric arguments are integers, the precision label is omitted.
For example, the type @code{QDP_F3_DiracFermion}
describes a single-precision four-spin, three-color spinor field.
The general color choice @code{N} can also be used for specialized
SU(2) or SU(3) at the cost of degrading performance.

@section Color and Precision Uniformity

In standard coding practice it is assumed that a user keeps one of the
precision and color options in force throughout the compilation.  So
as a rule all functions in the interface take operands of the same
precision and color.  As with data type names, function names come in
generic and color- and precision-specific forms, as described in the
next section.  Exceptions to this rule are functions that explicitly
convert from double to single precision and vice versa.  These and
functions that do not depend on color or precision are divided among
thirteen separate libraries.  If the user chooses to adopt color and
precision uniformity, then all variables can be defined with generic
types and all functions accessed through generic names.  The
prevailing color and precision is then defined through macros.  The
interface automatically translates data type names and function names
to the appropriate specific type names through typedefs and macros.
With such a scheme and careful coding, changing only two macros and
the QDP library converts code from one color and precision choice to
another.

@section Breaking Color and Precision Uniformity

It is permissible for a user to mix precision and color choices.  This
is done by declaring variables with specific type names, using
functions with specific names, and making appropriate precision
conversions when needed.  In this case it may be necessary to link
against a larger set of libraries.


@c ====================================================================
@node     QDP Functions
@chapter  QDP Functions
@c ====================================================================

The QDP functions are grouped into the following categories:

@itemize
@item Entry and exit from QDP
@item Layout utilities
@item Data parallel functions
@item Data management utilities
@item Subset definition
@item Shift creation
@item I/O utilities
@item Temporary exit and reentry
@item Optimization calls
@end itemize

@section Entry and exit from QDP

QDP can be started at any time, however field operations cannot be
used until the layout is created.
In the mean time it will be possible for the user to read input parameters
and broadcast them to all nodes.
It may also be possible to get parameters from the environment.
This procedure is stil under development so, for now, you're on your own.

@strong{[The startup procedure needs more thought - CD]}

@c @subheading Entry to QDP
@sfunce{
Entry to QDP,
void QDP_initialize,
int *argc@comma{} char ***argv,
Starts QDP.,
QDP_initialize(&argc@comma{} &argv);}

The routine @code{QDP_initialize} is called once by all nodes and
starts QDP operations.
It initialiazes message passing, but does not setup the site layout
(see @code{QDP_create_layout} and related functions).
It also defines the global variable
@code{int QDP_this_node;}
specifying the logical node number of the current node.

@c @subheading Exit from QDP
@sfunce{
Exit from QDP,
void QDP_finalize,
void,
Exits QDP.,
QDP_finalize();}

This call provides for an orderly shutdown.  It is called by all
nodes. It concludes all communications, does housekeeping, if needed
and performs a barrier wait for all nodes.  Then it returns control to
the calling process.

@c @subheading Panic exit from QDP
@sfunce{
Panic exit from QDP,
void QDP_abort,
int status,
Panic shutdown of the process.,
QDP_abort(1);}

This routine may be called by one or more nodes.  It sends kill
signals to all nodes and exits with exit status @code{status}.

@c @subheading Check for initialization
@sfunce{
Check for initialization,
int QDP_initialized,
void,
Checks if QDP is initialized.,
if(!QDP_initialized()) QDP_initialize(&argc@comma{} &argv);}

@c @subheading Control profiling
@sfunce{
Control profiling,
int QDP_profcontrol,
int new,
Controls profiling.,
old = QDP_profcontrol(new);}

Profiling results are only available for code that is compiled with
the macro @code{QDP_PROFILE} defined.  This must be defined before
the qdp.h header is included.  When @code{QDP_finalize} is called
a list of QDP function and call times will be sent to stdio on
node 0.  This function toggles the accumulation of the profiling
statistics within the profiled sections of code.
A value of zero turns the collection of timing info off and
nonzero values turn it on.  It is on by default.

@c @subheading Control checking communications
@sfunce{
Control checking communications,
int QDP_check_comm,
int new,
Controls checking communications.,
old = QDP_check_comm(new);}

A nonzero value turns the internal communications checksums on and
zero turns it off.  It is off by default.


@section Layout utilities

The layout routine determines which nodes get which lattice sites and
in what linear order the sites are stored.  It has entry points that
allow a user to access single site data extracted from a QDP lattice
field.  The layout must be created before any operations on QDP field
objects are allowed.  If a user removes data from a QDP lattice object
(see @code{QDP_expose} or @code{QDP_extract}) and wishes to manipulate
the data on a site-by-site basis, the global entry points provided
here are needed to locate the site data.

Some implementations may have a built-in tightly constrained layout.
In flexible implementations there may be several layout choices,
thereby allowing the user the freedom to select one that works best
with a given application.  Furthermore, such implementations may allow
the user to create a custom layout to replace one of the standard
layouts.  As long as the custom layout procedure provides the entry
points and functionality described here, compatibility with the
remainder of the QDP library is assured.

@subheading Defining the layout

Prior to creating the layout the layout parameters must be defined.
This is done through function calls.

@funce{
void QDP_set_latsize,
int nd@comma{} int size[],
Sets number of spacetime dimensions and lattice size.@*
No default.  Must always be set.,
QDP_set_latsize(4@comma{} size);}

@funce{
void QDP_create_layout,
void,
Lays out the sites.,
QDP_create_layout();}

All layout parameters must be initialized through the @code{set} function
calls prior to creating the layout.

After creating the layout the following global variables are accessible.
The predefined lattice subsets for specifying even, odd, and
global subsets of the lattice:

@code{QDP_Subset QDP_even, QDP_odd, QDP_all;}

The even and odd subsets are elements of a two-element subset array
@code{QDP_even_odd}, such that

@example
@code{QDP_even = QDP_even_odd[0];}
@code{QDP_odd  = QDP_even_odd[1];}
@end example

It also creates the nearest-neighbor shifts 

@code{QDP_shift QDP_neighbor[];}

for each coordinate direction.  
And finally the variable

@code{int QDP_sites_on_node;}

gives the number of sites assigned to a node by the layout utility.
Note that this may vary between nodes.

The following global entry points are provided by the
@code{QDP_create_layout} procedure:

@c @subheading Number of dimensions
@sfunce{
Number of dimensions,
int QDP_ndim,
void,
Returns the number of dimensions.,
ndim = QDP_ndim();}

@c @subheading Length of lattice in a given direction
@sfunce{
Length of lattice in a given direction,
int QDP_coord_size,
int i,
Returns length of lattice in direction @code{i}.,
nx = QDP_coord_size(0);}

@c @subheading Length of lattice in all directions
@sfunce{
Length of lattice in all directions,
void QDP_latsize,
int latsize[],
Returns lattice dimensions into array @code{latsize}.,
QDP_latsize(latsize);}

@c @subheading Length of lattice in all directions
@sfunce{
Length of lattice in all directions,
size_t QDP_volume,
void,
Returns lattice volume.,
vol = QDP_volume();}

@c @subheading Node number of site
@sfunce{
Node number of site,
int QDP_node_number,
int x[],
Returns logical node number containing site @code{x}.,
node = QDP_node_number(x);}

@c @subheading Linear index of site
@sfunce{
Linear index of site,
int QDP_index,
int x[],
Returns the linearized index for the lattice site @code{x}.,
k = QDP_index(x);}

The linear index returned by @code{QDP_index} ranges from 0 to
@code{QDP_sites_on_node} - 1.

@c @subheading Number of sites on a node
@sfunce{
Number of sites on a node,
int QDP_numsites,
int node,
Return the number of sites on a node.  Same as @code{QDP_sites_on_node}
if @code{node = QDP_this_node},
k = QDP_numsites(i);}

@c @subheading Map node and linear index to coordinate
@sfunce{
Map node and linear index to coordinate,
void QDP_get_coords,
int x[]@comma{} int node@comma{} int index,
Returns site coordinates @code{x} for the given node
@code{node} and linear index @code{index}.,
QDP_get_coords(x@comma{} 0@comma{} 31);}

@c @subheading Defining the spacetime coordinate
@sfunce{
Defining the spacetime coordinate,
void QDP_I_eq_coord,
@tI{} *r@comma{} int i,
The @code{i}th spacetime coordinate.,
QDP_Int *coord_z;@*
QDP_I_eq_coord(coord_z@comma{} 2);}

The call @code{QDP_I_eq_coord(&coord[i],i)} fills an integer lattice
field @code{coord[i]} with a value on each site equal to the integer
value of the @emph{i}th space-time coordinate on that site.


@section Naming Conventions for Data Parallel Functions

Data parallel functions are described in detail in @ref{Function Details}.
Here we desribe the naming conventions.
Data parallel function names are constructed with a pattern that suggests
their functionality.
Thus the function

@code{QDP_V_eq_M_times_V(c, u, b, s);}

carries out the product

@code{c[x] = u[x]*b[x];}

for all lattice coordinates @code{x} belonging to the subset @code{s}.
where @emph{c} and @emph{b} are pointers to lattice staggered fermion vector
fields and @emph{u} is a pointer to a lattice color matrix field.
The elements of the function name are separated by an underscore
(@code{_}) for readability.
All function names in this interface begin with @code{QDP}.
The specific name continues with a precision and color label
as in @code{QDP_F3_V_eq_M_times_V} for single precision @emph{SU(3)}.
Then comes a string of elements that mimics the algebraic expression.
The next character @code{V} abbreviates the type for the destination
operand, in this case the argument @code{c}.
The abbreviations are listed in @ref{Datatypes}.
The next string @code{eq} specifies the assignment operator.
In this case it is a straight replacement, but modifications are also
supported, as described below.
Then comes the first rhs operand type @code{M} followed by a string
@code{times} specifying the operation and a character @code{V}
specifying the second rhs operand type.

Supported variants of the assignment operator are tabulated below.

@multitable @columnfractions .2 .13
@hline
@item Abbreviation @tab Meaning
@hline
@item eq           @tab @math{=}
@item peq          @tab @math{+=}
@item meq          @tab @math{-=}
@item eqm          @tab @math{=-}
@hline
@end multitable

Some functions allow all of these and some take only a simple replacement (eq).

@subheading Constant Arguments

In some cases it is desirable to keep an argument constant over the
entire subset.  For example the function

@code{QDP_V_eq_c_times_V(c,z,b,s)}

multiplies a lattice field of color vectors by a complex constant as in

@code{c[x] = z*b[x]}

for @code{x} in subset @code{s}.
In this case we specify that the argument is constant (coordinate-independent)
by writing the type abbreviation in lower case: @code{c}.

@subheading Color argument for @emph{SU(N)}

For the general color case @emph{SU(N)} the specific function requires an
extra argument giving the number of colors.  It always comes first.
Thus in the above example we would write

@code{QDP_FN_V_eq_c_times_V(nc, c, z, b, s);}

where @code{nc} specifies the number of colors.  In normal practice,
the variable @code{nc} should be replaced by the required user-defined
macro @qdpNcMacro specifying the prevailing number of colors.  The
generic function is actually a macro and is automatically converted to
this usage with @qdpNcMacro for the first argument.  However, if the
specific name is used, the user must supply the argument.

@subheading Adjoint

The adjoint of an operand is specified by a suffix @code{a} after the
type abbreviation.  Thus

@code{QDP_V_eq_Ma_times_V(c, u, b, s);}

carries out the product

@code{c[x] = adjoint(u[x])*b[x];}

for all sites @code{x} in subset @code{s}.

@subheading Shift

A shift in an operand is specified by a prefix lowercase @code{s} before
the type abbreviation.  (See the discussion of shifts below.) Thus

@code{QDP_V_eq_sV(c, b, dir, sign, s);}

shifts staggered fermion data along the direction specified by @code{dir}
and @code{sign} for all sites @code{x} in destination subset @code{s}.

@subheading Operations on arrays of fields

Some of the routines can operate on multiple fields at a time.
These functions are designated by placing a @code{v} in front of the
@emph{eqop} operator.  The allowed @emph{eqop}'s are then
@code{veq}, @code{vpeq}, @code{vmeq} and @code{veqm}.
All arguments to the function are then made into arrays of the type
the original argument was @emph{except} for the subset.
Even scalar values (QLA types) and other parameters are turned into arrays.
The length of the arrays is then given as the last argument.
For example the function

@code{QDP_F3_V_peq_M_times_V( QDP_F3_ColorVector *r, QDP_F3_ColorMatrix *a, @*
@ @ @ @ QDP_F3_ColorVector *b, QDP_Subset s );}

@noindent
becomes

@code{QDP_F3_V_peq_M_times_V( QDP_F3_ColorVector *r[], QDP_F3_ColorMatrix *a[],
@* @ @ @ @ QDP_F3_ColorVector *b[], QDP_Subset s, int n );}

@noindent
This has the same effect as the following code

@code{for(i=0; i<n; i++)
QDP_F3_V_peq_M_times_V( r[i], a[i], b[i], s );}

@noindent
however it may be implemented in a more efficient manner.
It is permissible to have multiple array elements point to the same field.
The result will always agree with that of the above @code{for} loop.


@section Creating and destroying lattice fields

All QDP functions expect that lattice field arguments point to fields
that have already been created.  The sole exception to this rule is
the creation utility itself, which returns a pointer

@c @subheading Creating a lattice field
@sfuncte{
Creating a lattice field,
@var{Type} * QDP_create_@var{T},
void,
Creates lattice field of type @var{Type}.,
@allTypes,
u = QDP_create_M();}

In prototype specifications throughout this document the notation
@emph{Type} specifies the generic or specific datatype name matching the
abbreviation @emph{T} according to the table in @ref{Datatypes}.

@c @subheading Destroying a lattice field
@sfuncte{
Destroying a lattice field,
void QDP_destroy_@var{T},
@var{Type} *a,
Frees memory associated with field @code{a}.,
@allTypes,
QDP_destroy_M(u);}


@section Subsets

All QDP linear algebra and shift operations require specifying the
subset of the lattice on which the operation is performed.  The subset
may be the entire lattice.  When defining subsets, it is often
convenient to partition the lattice into multiple disjoint subsets
(e.g. time slices or checkerboards).  Such subsets are defined through
a user-supplied function that returns a range of integers
0,1,2,...,n-1 so that if f(x) = i, then site @emph{x} is in
partition @emph{i}.  A single subset may also be defined by limiting the
range of return values to a single value (i.e. 0).  This procedure may
be called more than once, and sites may be assigned to more than one
subset.  Thus, for example an even site may also be assigned to a time
slice subset and one of the subsets in a 32-level checkerboard scheme.
A subset definition remains valid until @code{QDP_destroy_subset} is
called.

@subheading Defining a subset

Subsets are defined through the data type @code{QDP_Subset}

@funce{
QDP_Subset * QDP_create_subset,
int (*func)(int x[]@comma{} void *args)@comma{} void *args@comma{}
int argsize@comma{} int n,
Creates an array of @code{n} subsets based on @code{func}.,
QDP_Subset ts[nt];@*
ts = QDP_create_subset(timeslice@comma{} NULL@comma{} 0@comma{} nt);}
@c  where timeslice(x@comma{} NULL) = x[3].

The extra arguments @code{args} are passed directly to the function and saved
in case the subset function is needed again when doing shifts involving the
subset.  Therefore the function should not depend on any other global
parameters that may change later in the program.
It is permissible to call @code{QDP_create_subset} with n = 1.
In this case the function must return zero if the site is in the
subset and nonzero if not.  (Note, this is opposite the @emph{true},
@emph{false} convention in C).

@c @subheading Destroying subsets
@sfunce{
Destroying subsets,
void QDP_destroy_subset,
QDP_subset s[],
Destroys all subsets created with @code{s}.,
QDP_destroy_subset(ts);}

This procedure frees all memory associated with the subset object @emph{s}.
The @code{QDP_subset *} value @emph{s} should be the object
returned by @code{QDP_create_subset}.  All subsets in the array
@emph{s} are destroyed.

@subheading Reductions on subsets

Reduction operations (norms, inner products, global sums) come in two
variants according to whether the result is computed on a single
subset of the lattice or on multiple subsets.  Thus the operation

@example
  QLA_Complex z;
  QDP_ColorVector *a, *b;
  QDP_c_eq_V_dot_V(&z, a, b, QDP_even);
@end example

sums the dot product of the lattice staggered fermion fields @emph{a}
and @emph{b} on the even sites and stores the result in @emph{z}.
The operation

@example
  QLA_Complex z[nt];
  QDP_ColorVector *a, *b;
  QDP_c_eq_V_dot_V_multi(z, a, b, ts, nt);
@end example

with the timeslice subsets illustrated above computes the dot product
summed separately on each timeslice and stores the sums in the array
@emph{z}, so that the value in @emph{z[i]} results from the sum on the
subset @emph{ts[i]}.

@section Shifts

Shifts are general communication operations specified by any
permutation of sites.  Nearest neighbor shifts are a special case and
are preinitialized by @code{QDP_initialize}. Arbitrary displacement
shifts are an intermediate generalization and are created with
@code{QDP_create_shift}.  Arbitrary permutations are created with
@code{QDP_create_map}.  However they are created, all shifts are
specified by a @emph{direction} label @emph{dir} of type @code{QDP_Shift}
and a sign @emph{sign} of type @code{QDP_ShiftDir} that takes one of two
predefined values @code{QDP_forward} and @code{QDP_backward}.

Shifts are treated syntactically as a modification of a QDP argument
and are specified with a prefix @emph{s} before the type abbreviation
for the shifted field. Thus, for example,

@code{QDP_H_eq_sH(r, a, dir, sign, s);}

@noindent
shifts the half fermion field @emph{a} along direction @emph{dir}, forward or
backward according to @emph{sign}, placing the result in the field @emph{r}.
Nearest neighbor shifts are specified by values of the global shift
@code{QDP_neighbor[mu]} with @code{mu} in the range [0, Ndim-1].
The sign is @code{QDP_forward} for shifts from the positive direction, and
@code{QDP_backward} for shifts from the negative direction.  That is,
for @code{QDP_forward} and @code{dir = QDP_neighbor[mu]}, r(x) = a(x+mu).
For more general shifts, the direction @emph{dir} is specified by the object
returned by @code{QDP_create_shift} or @code{QDP_create_map} and @emph{sign}
must be either @code{QDP_forward} or @code{QDP_backward} to specify the
permutation or its inverse, respectively.

The subset restriction applies to the destination field @emph{r}.
Thus a nearest neighbor shift operation specifying the even subset shifts
odd site values from the source @emph{a} and places them on even site
values on the destination field @emph{r}.

@subheading Creating displacement shifts

@funce{
QDP_Shift QDP_create_shift,
int d[],
Creates a shift defined by the displacement vector @code{d}.,
int d[4] = @{0@comma{}1@comma{}2@comma{}0@};@*
QDP_Shift knight[4][4];@*
knight[2][3] = QDP_create_shift(d);}

Calling with a displacement vector @{1,0,0,0@} would reproduce
the shift @code{QDP_neighbor[0]}.

@subheading Creating arbitrary permutations

@funce{
QDP_Shift QDP_create_map,
int *(func*)(int coord[Nd]@comma{} void *args)@comma{}
void *args@comma{} int argsize,
Creates a shift specified by the permutation map @code{func}.,
int mu = 1;@*
QDP_Shift mirror[4];@*
mirror[mu] = QDP_create_map(reflect@comma{} &mu@comma{} sizeof(mu));}
@c where @{\tt reflect(x@comma{}mu)@} maps $x_\mu$ to $L_\mu - 1 - x_\mu$.

The return value is used in the various linear
algebra calls involving shifts.  The arguments @emph{args} are passed
through to the calling function.  The @emph{argsize} parameter
specifies the byte length of the argument array or structure.

The implementation may choose to postpone construction of a shift.
Thus it is required that the callback function @emph{func} be static
and invariant, i.e. a function call with the same arguments must give
the same result, even if the call is postponed.
The parameters @emph{args} are copied at the moment the shift is created,
however, so they may be volatile.
The size argument @emph{argsize} makes copying possible.

@subheading Destroying a shift

The corresponding destruction function is @code{QDP_destroy_shift}.

@funce{
void QDP_destroy_shift,
QDP_Shift dir,
Frees memory associated with the map @emph{dir}.,
QDP_destroy_shift(dir);}

@section I/O utilities

@strong{[Under development.]}

@section Temporary entry and exit from QDP

For a variety of reasons it may be necessary to remove data from QDP
structures.  Conversely, it may be necessary to reinsert data into QDP
structures.  For example, a highly optimized linear solver may
operate outside QDP.  The operands would need to be extracted from QDP
fields and the eventual solution reinserted.  It may also be useful to
suspend QDP communications temporarily to gain separate access to the
communications layer.  For this purpose function calls are provided to
put the QDP implementation and/or QDP objects into a known state,
extract values, and reinsert them.

@c @subheading Exposing QDP data
@sfuncte{
Exposing QDP data,
@var{QLA_Type} * QDP_expose_@var{T},
@var{Type} *src,
Deliver data values from field @code{src}.,
@allNumericTypes,
r = QDP_expose_M(a);}

This function grants direct access to the data values contained in the
QDP field @emph{src}.  The return value is a pointer to an array of QLA
data @emph{dest} of type @emph{T}.  The order of the data is given by
@code{QDP_index}.  No QDP operations are permitted on exposed
data until @code{QDP_reset} is called. (See next.)

@c @subheading Returning control of QDP data
@sfuncte{
Returning control of QDP data,
void QDP_reset_@var{T},
@var{Type} *field,
Returns control of data values to QDP.,
@allNumericTypes,
QDP_reset_M(r);}

This call signals to QDP that the user is ready to resume QDP
operations with the data in the specified field.

@c @subheading Extracting QDP data
@sfuncte{
Extracting QDP data,
void QDP_extract_@var{T},
@var{QLA_Type} *dest@comma{} @var{Type} *src,
Copy data values from field @code{src} to array @code{dest}.,
@allNumericTypes,
QDP_extract_M(r@comma{} a@comma{} QDP_even);}

The user must allocate space of size
@code{QDP_sites_on_node*sizeof(QLA_Type)} for the destination array
before calling this function, regardless of the size of the subset.
This function copies the data values contained in the QDP field @emph{src}
to the destination field.  Only values belonging to the specified
subset are copied.  Any values in the destination array not associated
with the subset are left unmodified.  The order of the data is given
by @code{QDP_index}.  Since a copy is made, QDP operations
involving the source field may proceed without disruption.

@c @subheading Inserting QDP data
@sfuncte{
Inserting QDP data,
void QDP_insert_@var{T},
@var{Type} *dest@comma{} @var{QLA_Type} *src,
Inserts data values from QLA array @code{src}.,
@allNumericTypes,
QDP_insert_M(a@comma{} r);}

Only data associated with the specified subset are inserted.
Other values are unmodified.  The data order must conform to
@code{QDP_index}.  This call, analogous to a fill operation, is
permitted at any time and does not interfere with QDP operations.

@subheading Suspending QDP communications

If a user wishes to suspend QDP communications temporarily and carry
on communications by other means, it is first necessary to call
@code{QDP_suspend_comm}.

@funce{
void QDP_suspend_comm,
void,
Suspends QDP communications.,
QDP_suspend_comm();}

No QDP shifts can then be initiated until @code{QDP_resume} is called.
However QDP linear algebra operations without shifts may proceed.

@subheading Resuming QDP communications

To resume QDP communications one uses

@funce{
void QDP_resume_comm,
void,
Restores QDP communications.,
QDP_resume_comm();}

@section Optimization Calls

The following procedure is included to aid in optimization of the
QDP implementation

@c @subheading Marking discarded data
@sfuncte{
Marking discarded data,
void QDP_discard_@var{T},
@var{Type} *a,
Indicates data in @code{a} is no longer needed.,
@allNumericTypes,
QDP_discard_M(utemp);}

The field is not destroyed and memory is not released.  For that
purpose, see @code{QDP_destroy}.  This call allows the implementation
to cancel the deferred resolution of a lazy shift.  It is a runtime
error to attempt to use discarded data as an rvalue (source operand or
incremented destination) in any subsequent operation.  However, once
the field is used as an lvalue (fully replaced destination), data
integrity is automatically reinstated.


@macro functionhookfills
@c @subheading Function fills
@sfunct{
Function fills,
QDP_@var{T}_eq_func,
@var{Type} *r@comma{} void (*func)(@var{QLA_Type} *dest@comma{} int coords[])@comma{} @var{subset},
calls func(&r[x]@comma{} x) for all coordinates x in subset,
I@comma{} R@comma{} C@comma{} V@comma{} H@comma{} D@comma{} M@comma{} P}
@end macro

@macro functionhookunary
@end macro

@macro functionhooktype
@end macro

@macro functionhookbinary
@end macro

@macro functionhookternary
@end macro

@macro functionhookboolean
@end macro

@c ====================================================================
@node     Function Details
@chapter  Function Details
@c ====================================================================

This section describes in some detail the names and functionality for
all functions in the interface involving linear algebra with and
without shifts.  Because of the variety of datatypes, and assignment
operations, there are a few hundred names altogether.  However, there
are only a couple dozen categories.  It is hoped that the construction
of the names is sufficiently natural that with only a little practice,
the user can guess the name of any function and determine its
functionality without consulting a list.

In prototype specifications throughout this document the notation
@var{Type} specifies the generic or specific datatype name matching
the abbreviation @var{T} according to the table in @ref{Datatypes}.
We also introduce the shorthand

@c @code{#typedef const QDP_Subset Subset}
@code{#define @var{subset} QDP_Subset subset}

Unless otherwise indicated, operations occur on all sites in the
specified subset.

@section Functions involving shifts

@c @subheading Shifting
@sfuncvt{
Shifting,
QDP_@var{T}_eq_s@var{T},
@var{Type} *r@comma{} @var{Type} *a@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
QDP_@var{T}_veq_s@var{T},
@var{Type} *r[]@comma{} @var{Type} *a[]@comma{} QDP_Shift s[]@comma{} QDP_ShiftDir d[]@comma{} @var{subset}@comma{} int n,
r = shift(a),
I@comma{} R@comma{} C@comma{} V@comma{} H@comma{} D@comma{} M@comma{} P}

@c @subheading Left multiplication by shifted color matrix
@sfunct{
Left multiplication by shifted color matrix,
QDP_@var{T}_eq_sM_times_@var{T},
@var{Type} *r@comma{} QDP_ColorMatrix *a@comma{} @var{Type} *b@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
r = shift(a) * b,
V@comma{} H@comma{} D@comma{} M@comma{} P}

@c @subheading Left multiplication of shifted field by color matrix
@sfunct{
Left multiplication of shifted field by color matrix,
QDP_@var{T}_eq_M_times_s@var{T},
@var{Type} *r@comma{} QDP_ColorMatrix *a@comma{} @var{Type} *b@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
r = a * shift(b),
V@comma{} H@comma{} D@comma{} M@comma{} P}

@c @subheading Left multiplication by color matrix then shift
@sfunct{
Left multiplication by color matrix then shift,
QDP_@var{T}_eq_sM_times_s@var{T},
@var{Type} *r@comma{} QDP_ColorMatrix *a@comma{} @var{Type} *b@comma{} QDP_Shift s@comma{} QDP_ShiftDir d@comma{} @var{subset},
r = shift(a * b),
V@comma{} H@comma{} D@comma{} M@comma{} P}

@include functions.texi

@bye
